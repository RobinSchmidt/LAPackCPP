

f2c functions that are needed: i_len, s_copy, s_cmp, i_nint

Functions that have to be translated next:

  dlascl2

Functions that have been translated:

Lapack-Drivers:
  dgbsv, dgbsvx, dgbsvxx

Lapack-Computational:
  dgbcon, dgbequ, dgbequb, dgbrfs, dgbrfsx, dgbtrf, dgbtrs, dgbtf2, 
  dla_gbrpvgrw__

Lapack-Auxiliary: 
  dlacn2, dlabad, dlacpy, dlangb, dlantb, dlaqgb, dlaswp, dlatbs,  ieeeck, ilaenv, 
  iparmq, disnan (reimplemented), dlassq, drscl,

Blas Level 1:
  dasum, daxpy, dcopy, ddot, idamax, lsame, dscal, dswap, xerbla

Blas Level 2:
  dger, dgbmv, dgemv, dtbsv, 

Blas Level 3:
  dgemm, dtrsm  
  
  
  
check labad - it has been translated from double precision version and may 
not be appropriate for single (magic numbers are used) - maybe re-implement

Implement the "lamch" auxiliary routine in a generic way using templates and
explicit specializations - this is one of the places, where actually some new
code needs to be written to make it work correctly in a template-based 
context. The function lamch should call function templates where explicit
specializations exist for float and double which return the required values
by delegating to std::numeric_limits. The bad news is that lamch doesn't take
a parameter of the type of which we want to inquire the info, so we may need to
add a dummy parameter to the declaration and change all the calls to lamch 
accordingly to pass a dummy...hopefully not too much work.....
...done - Verify implementation of lamch - especially, if it works with float 
and double as it should with unit tests
  
Some functions define static local variables (for example laswp) - maybe we 
should use non-static local varibales instead? Because when two different 
threads use a routine concurrently, each needs it own local variables. Maybe 
define a macro LA_STATIC that evaluates to static - so we may globally select
whether static or local (stack-allocated) variables shall be used. When there
are a lot of local variables, maybe we could get stack overflow, if they are 
not static? We should have the option to roll back to static, if necessarry, 
so using a macro seems a suitable approach. Another approach would be to 
embed the routines in a class and use member variables...but that may go 
very much against the grain of the library design and in routines converted
later, we would have to make a lot of edits...hmm...bad! for the time being,
i'll just leave it as is...In my typical scenario (of audio apps and plugins),
the routines will be used from one therad only anyway. Or maybe some of them
are even used to remember a state between calls? Check that carefully before 
switching to locals.


For the naming conventions: We have currently retained the l and i prefixes
(for example in iamax, lsame) for routines that work with integers and 
logicals (mostly they return values of the respective type). Maybe get rid
of these prefixes, too - or maybe not.